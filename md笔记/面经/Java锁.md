## Java锁

[主要参考]: https://tech.meituan.com/2018/11/15/java-lock.html

### 1、悲观锁和乐观锁

乐观锁和悲观锁在Java和数据库中都有此概念的实际应用。

对于同一个数据的并发操作：

- 悲观锁是悲观的认为自己在使用数据时一定会有其他线程来修改数据，因此在获取数据的时候会加锁，确保数据不会被其他线程修改。我们常用的synchronized关键字和ReentrantLock 类都是悲观锁；
- 乐观锁则乐观的认为自己在使用数据的时候没有其他线程来修改自己的数据，只是在更新数据时去判断之前有没有数据更新了这个数据，如果没有，就直接将自己修改的数据写入，如果有，则根据不同的实现方式来执行不同的操作（通过报错或自动重试）。乐观锁在Java中是通过无锁编程来实现的，最常采用的时CAS算法，Java原子类的递增就是通过CAS自旋来实现的。

[乐观锁失败操作]: https://blog.csdn.net/HXNLYW/article/details/94558449

- 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
- 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

### 2、自旋锁和自适应自旋锁

**CAS**：CAS全程是 Compare And Swap ，是一种无锁算法。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。

CAS算法涉及到三个操作数：

- 需要读写的内存值V
- 进行比较的值A
- 需要写入的新值B

当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行仍和操作。一般情况下，“更新“ 是一个不断重试的。

CAS可能出现的三大问题：

- **ABA问题**。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
  - JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，也就是通过时间戳来解决。具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。
- **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。
- **只能保证一个共享变量的原子操作**。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
  - Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

而说回自旋锁，阻塞或者唤醒一个线程需要操作系统切换CPU状态来完成，这种状态切换需要消耗一定的时。而如果同步代码块中的数据过于简单，状态切换的时间可能比用户代码执行的时间还要长。在一些场景下，为了一小段执行操作的时间而去切换线程，这样子带来的时间开销有些得不偿失。如果系统有多个处理器，能够让两个或两个以上的线程并行执行，我们就可以让后面的那个请求锁的进程不放弃CPU执行时间，看看持有锁的线程会不会很快就释放锁。

而为了让这个线程”稍等一下“，我们就需要让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程释放了锁，那么当前线程就不必阻塞而是直接获取同步资源，从而避免切换线程的开销，这就是**自旋锁**。

自旋自身也是有缺点的，它无法代替阻塞。因为自选本身也需要占用处理器时间，所以，当自旋达到一定次数（默认10次，可以使用-XX:PreBlockSpin来更改）还是没有成功获取锁，我们就不能让他继续等待了，而是挂起该线程。

而**自适应自旋锁**意味着自旋的次数不再固定，而是由前一次在同一个锁上自旋的时间和锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得了锁，并且持有锁的线程正在进行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待更长的时间；但是，如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁的过程中，可能会省略自旋的过程，直接阻塞线程，避免浪费处理器资源。

### 3、无锁、偏量锁、轻量级锁、重量级锁

这四个锁都是针对synchronized关键字的。

### 4、公平锁和非公平锁



### 5、共享锁和排他锁



### 6、可重入锁和非可重入锁