---
title: leetcode题解：预测赢家
date: 2020-09-01 08:35:00
categories: 
- leetcode题解
tags:
- 动态规划
---

# 预测赢家

> [486.预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)
>
> ​		给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。
>
> ​		给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。

​		拿到题目，第一瞬间想到的就是贪心，每次都拿左右两端出现的最大值，但仔细看看，便发现并不成立，例如[1, 5, 233, 7]，想赢必须先拿1。贪心算法所作的贪心选择可以依赖于以往所作过的选择，但决不依赖于将来所作的选择，也不依赖于子问题的解。但这题是需要依赖子问题的解的，于是我把目光投到了动态规划。

​		当数组长度为偶数时，先手必赢，因为最终的两种路线先手都可以走。然后，当数组只有一个数时，先手也必赢，并且两者分数的差即为nums[i]。于是，我们可以将dp数组表示为：**在[i,j]区间内，当前要拿分数的玩家与后拿分数的玩家分数差的最大值**（注意是当前要拿数的玩家，这个玩家不一定就是最开始的先手玩家）。在[i,j]区间内，我们不需要考虑之后怎么拿，只需要考虑这个区间的结果。当我们拿i时，另一个玩家只能在剩余的[i+1,j]区间内尽可能拿有利于自己的分数，这样子我们就可以推出状态转移方程：

```java
dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
```

最后，我们要求的即为dp\[0][len-1]是否大于或等于0。

```java
class Solution {
    public boolean PredictTheWinner(int[] nums) {
        //如果nums长度为偶数，则先手必赢。如[3,5,4,6,5,3]，如果先手从左开始则后手赢，但先手可以直接走后手赢的路线（即从右端开始），则先手赢
        if (nums.length % 2 == 0) {
            return true;
        }
        //dp[i][j]表示：在[i,j]区间内，当前的要拿数的玩家与后拿数的玩家分数差的最大值（注意是当前要拿数的玩家，这个玩家不一定就是最开始的先手玩家）
        int[][] dp = new int[nums.length][nums.length];
        //当仅有一个数时，两者最大差值必为此数
        for (int i = 0; i < nums.length; i++) {
            dp[i][i] = nums[i];
        }
        //状态转移方程:dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])
        //很明显，i必须从右往左遍历，而j必须从左往右遍历
        for (int i = nums.length - 2; i >= 0; i--) {
            for (int j = i + 1; j < nums.length; j++) {
                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
            }
        }
        return dp[0][nums.length - 1] >= 0;
    }
}
```

