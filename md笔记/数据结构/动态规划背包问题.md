# 动态规划背包问题

## 1、01背包问题

> 一共有N件物品，第 i（i从1开始）件物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

动态规划思路：（应该注意到前i个商品在确定重量上限时的最大价值不会受之后商品的影响）

1. 找出dp数组代表的意义：`dp[i][j]`表示在背包容量上限为j时，前i个商品的最大价值。
2. 动态递推方程：`dp[i] [j] = Math.max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i] );` 即对于`dp[i][j]`有两种选择:
   1. 不拿当前这件物品，总价值仍然是背包容量上限为j时，前i - 1件商品的最大价值，即`dp[i - 1][j]`
   2. 拿当前这件物品，总价值就为背包容量上限为j - w[i]时，前i - 1件商品的最大价值加上当前商品的价值，即用`dp[i - 1][j - w[i]] + v[i]`;
3. 遍历方式：i依赖于i - 1，所以外层i的遍历需要从0到N，而j无限制（因为上一排的数据都是已知的）。

> 实例：有编号 0--4的五件物品，它们的重量分别为 4,5,6,2,2, 它们的价值分别为 6,4,5,3,6。现有一个承重为 10 的背包，求背包能装的最大价值为多少？[牛客链接](https://www.nowcoder.com/questionTerminal/708f0442863a46279cce582c4f508658)

| i\j  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 6    | 6    | 6    | 6    | 6    | 6    | 6    |
| 1    | 0    | 0    | 0    | 0    | 6    | 6    | 6    | 6    | 6    | 10   | 10   |
| 2    | 0    | 0    | 0    | 0    | 6    | 6    | 6    | 6    | 6    | 10   | 11   |
| 3    | 0    | 0    | 3    | 3    | 6    | 6    | 9    | 9    | 9    | 10   | 11   |
| 4    | 0    | 0    | 6    | 6    | 9    | 9    | 12   | 12   | 15   | 15   | 15   |

代码：

```Java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int W = input.nextInt();//最大重量
        int N = input.nextInt();//商品数量
        int[] wight = new int[N + 1];
        int[] value = new int[N + 1];
        for (int i = 1; i < N + 1; i++) {
            wight[i] = input.nextInt();
            value[i] = input.nextInt();
        }
        int[][] dp = new int[N + 1][W + 1];
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= W; j++) {
                if (j >= wight[i]) {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - wight[i]] + value[i]);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        System.out.println(dp[N][W]);
    }
}
```

## 2、一和零

> #### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)
>
> 给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。
>
> 请你找出并返回 `strs` 的最大子集的大小，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。
>
> 如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

```Java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[] one = new int[strs.length + 1];
        int[] zero = new int[strs.length + 1];
        //统计0、1数量
        for (int i = 0; i < strs.length; i++) {
            for (int j = 0; j < strs[i].length(); j++) {
                if(strs[i].charAt(j) == '0'){
                    zero[i + 1]++;
                }else{
                    one[i + 1]++;
                }
            }
        }
        //dp[i][j][k]表示对于前i个字符串，最多有j个0，k个1的情况下，最大子集大小
        int[][][] dp = new int[strs.length + 1][m + 1][n + 1];
        for (int i = 1; i <= strs.length; i++) {
            for (int j = 0; j <= m; j++) {
                for (int k = 0; k <=n; k++) {
                    //两种情况，把该字符串放入和不放入
                    if(zero[i] > j || one[i] > k){
                        dp[i][j][k] = dp[i - 1][j][k];
                    }else{
                        dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - zero[i]][k - one[i]] + 1);
                    }
                }
            }
        }
        return dp[strs.length][m][n];
    }
}
```

## 3、目标和

> #### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)
>
> 给你一个整数数组 `nums` 和一个整数 `target` 。
>
> 向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：
>
> - 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。
>
> 返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

```Java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        //动态规划其实依然是0/1背包的变种，只不过0/1背包是拿去不拿，此题是加或减，并且结果是求和而不是取较大值
        //dp[i][j]代表前i个字符且和为j的表达式数量
        //dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]
        //此题已经给出了最大和，但注意有正负！
        int sum = 0;
        int[][] dp = new int[nums.length + 1][3000];
        dp[0][1000] = 1;
        for (int i = 1; i <= nums.length; i++) {
            for (int j = -1000; j <= 1000; j++) {
                if(j - nums[i - 1] >= -1000){
                    dp[i][j + 1000] += dp[i - 1][j - nums[i - 1] + 1000];
                }
                if(j + nums[i - 1] <= 1000){
                    dp[i][j + 1000] += dp[i - 1][j + nums[i - 1] + 1000];
                }
            }
        }
        return dp[nums.length][target + 1000];
    } 
}
```

