# 排序算法

![](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\排序时间复杂度.png)

## 1、选择排序

基本原理：通过双重循环，外层循环循环n-1次，因为到最后一个数不需要再循环一次，内层循环通过不断比较相邻两数，前一个数大于后一个数就交换二者，循环结束后就可以把最大的数放在数组末尾。

时间复杂度：最坏时间复杂度为**O(n^2)**数组逆序的情况，每一次都需要交换完成。最好情况下的时间复杂度为O(n)，此时数组顺序，在第一遍循环完成后通过标志位得出此时数组已顺序，跳出循环。所以平均时间复杂度为O(n^2)。

稳定性：稳定，显然，在交换过程中如果两者相等并不会发生交换，所以冒泡排序是稳定排序.

空间复杂度:冒泡排序不需要额外构建数组,所以空间复杂度为O(1)

```java
package com.dreamin.test;

public class BubbleSortTest {
    public static void main(String[] args) {
        //int[] array = {1, 5, 8, 7, 6, 2};
        //int[] array = {1, 2, 3, 4, 5, 6, 7, 9};
        int[] array = {6, 5, 4, 2, 1, 0};
        bubbleSort(array);
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
    }

    private static void bubbleSort(int[] array) {
        boolean isSorted = true;
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    change(array, j, j + 1);
                    isSorted = false;
                }
            }
            if (isSorted == true) {
                break;
            } else {
                isSorted = true;
            }
        }

    }

    private static void change(int[] array, int m, int n) {
        int temp = array[m];
        array[m] = array[n];
        array[n] = temp;
    }
}

```



## 2、选择排序

原理:选择排序是通过每次循环把最小的元素提到数组前端来排序,与冒泡排序不同,选择排序并不是每次都交换,而只是把最小的保存下来,循环结束后再进行交换,节省了交换所需要的时间.

时间复杂度:选择排序必须执行完所有循环才能确定数组顺序,所以无论是最好情况还是最坏情况选择排序的时间复杂度都为O(n^2).

稳定性:比如{5,8,5,2,9},选择排序可能因为最后的交换把前面的交换到了后面,所以选择排序为不稳定排序.

空间复杂度:选择排序不需要额外创建数组,所以选择排序的空间复杂度为O(1)

```java
package com.dreamin.test;

public class SelectionSortTest {
    public static void main(String[] args) {
//        int[] array = {1, 5, 8, 7, 6, 2};
        //int[] array = {1, 2, 3, 4, 5, 6, 7, 9};
        int[] array = {6, 5, 4, 2, 1, 0};
        selectionSort(array);
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
    }

    private static void selectionSort(int[] array) {
        int min, key;
        for (int i = 0; i < array.length - 1; i++) {
            min = array[i];
            key = i;
            for (int j = i + 1; j < array.length; j++) {
                if (array[j] < min) {
                    min = array[j];
                    key = j;
                }
            }
            if (key != i) {
                array[key] = array[i];
                array[i] = min;
            }
        }
    }

}

```

## 3、插入排序

原理:把n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

时间复杂度:最坏时间复杂度为O(n^2),此时数组逆序,每一次循环都需要把无序数组的数插入到有序数组的最前端,最好情况的时间复杂度为O(n),此时数组顺序,无需进入插入的循环.所以平均时间复杂度为O(n^2)。

稳定性:稳定,插入排序不会改变相同数原来的位置.

空间复杂度:不需要额外创建数组,所以选择排序的空间复杂度为O(1)

```java
package com.dreamin.test;

public class InsertionSortTest {
    public static void main(String[] args) {
        //int[] array = {1, 5, 8, 7, 6, 2};
//        int[] array = {1, 2, 3, 4, 5, 6, 7, 9};
        int[] array = {6, 5, 4, 2, 1, 0};
        insertionSprt(array);
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
    }

    private static void insertionSprt(int[] array) {
        for (int i = 1; i < array.length; i++) {//从第二个数开始判断
            if (array[i] < array[i - 1]) {//如果array[i]>=array[i-1],就代表无需插入
                int temp = array[i];//保存待插入数
                int j;
                for (j = i; j > 0 && array[j-1] > temp; j--) {
                    array[j] = array[j - 1];//已排序数组大于待插入数的向后移位
                }
                array[j]=temp;//插入该数
            }
        }
    }
}

```

## 4、希尔排序

原理：希尔排序本质上就是对插入排序的优化改进，时间复杂度在O(n^1.3)到O(n^2)之间。

注意：希尔排序下虽然基于插入排序，但是并不是稳定排序，因为多个不同划分的区域分别插入排序可能会打乱相同数原本顺序。

```java
public class ShellsSortTest {
    public static void main(String[] args) {
//        int[] array = {1, 5, 8, 7, 6, 2};
//        int[] array = {1, 2, 3, 4, 5, 6, 7, 9};
        int[] array = {6, 5, 4, 2, 1, 0};
        shellsSort(array);
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
    }

    private static void shellsSort(int[] array) {
        for (int gap = array.length / 2; gap > 0; gap /= 2) {
            for (int i = gap; i < array.length; i++) {
                int temp = array[i];
                int j = i;
                if (temp < array[i - gap]) {
                    while (j - gap >= 0 && array[j - gap] > temp) {
                        array[j] = array[j - gap];
                        j -= gap;
                    }
                    array[j] = temp;
                }

            }
        }

    }
}

```

## 5、快速排序

原理：挖坑填数+分治法。

参考：https://blog.csdn.net/morewindows/article/details/6684558

时间复杂度：nlogn

最坏时间复杂度：O(n^2) 在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。

空间复杂度：主要是递归造成的栈空间的使用，平均复杂度为logn。

稳定性：不稳定

```java
package com.dreamin.test;

public class QuickSortTest {
    public static void main(String[] args) {
//        int[] array = {1, 5, 8, 7, 6, 2};
        //int[] array = {1, 2, 3, 4, 5, 6, 7, 9};
//        int[] array = {6, 5, 4, 2, 1, 0};
        int[] array = {72, 6, 57, 88, 60, 42, 83, 73, 48, 85};
        int left = 0;
        int right = array.length - 1;
        quickSort(array, left, right);
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
    }

    private static void quickSort(int[] array, int left, int right) {
        if (left < right) {
            int flag = array[left];
            int l = left;
            int r = right;
            while (l < r) {
                while (l<r && array[r] >= flag) {
                    r--;
                }
                if (l < r) {
                    array[l++] = array[r];
                }
                while (l<r && array[l] < flag) {
                    l++;
                }
                if (l < r) {
                    array[r--] = array[l];
                }
            }
            array[l]=flag;
            quickSort(array, left, l - 1);
            quickSort(array, l + 1, right);
        }
    }


}

```

## 6、归并排序

时间复杂度：所有情况下的时间复杂度都为O(nlogn)，因为递归深度必定为logn。

```java
package com.dreamin.test;

public class MergeSortTest {

    public static void main(String[] args) {
        //        int[] array = {1, 5, 8, 7, 6, 2};
        //int[] array = {1, 2, 3, 4, 5, 6, 7, 9};
//        int[] array = {6, 5, 4, 2, 1, 0};
        int[] array = {72, 6, 57, 88, 60, 42, 83, 73, 48, 85};
        int left = 0;
        int right = array.length - 1;
        int[] temp = new int[array.length];
        mergeSort(array, left, right, temp);
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
    }

    private static void mergeSort(int[] array, int left, int right, int[] temp) {
        //先分治，再合并
        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(array, left, mid, temp);
            mergeSort(array, mid + 1, right, temp);
            merge(array, left, mid, right, temp);
        }
    }

    private static void merge(int[] array, int left, int mid, int right, int[] temp) {
        int l = left, r = mid + 1, index = 0;
        while (l <= mid && r <= right) {
            if (array[l] <= array[r]) {
                temp[index++] = array[l++];
            } else {
                temp[index++] = array[r++];
            }
            while (l <= mid) {
                temp[index++] = array[l++];
            }
            while (r <= right) {
                temp[index++] = array[r++];
            }
        }
        for (int i = 0; i < index; i++) {
            array[left++] = temp[i];
        }
    }
}

```

## 7、基数排序

时间复杂度：

```java
package com.dreamin.test;

public class RadixSortTest {
    public static void main(String[] args) {
        //        int[] array = {1, 5, 8, 7, 6, 2};
        //int[] array = {1, 2, 3, 4, 5, 6, 7, 9};
//        int[] array = {6, 5, 4, 2, 1, 0};
//        int[] array = {72, 6, 57, 88, 60, 42, 83, 73, 48, 85};
        int[] array = {53, 3, 542, 748, 14, 214, 1000};

        int left = 0;
        int right = array.length - 1;
        radixSort(array);
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
    }

    private static void radixSort(int[] array) {
        int[][] bucket = new int[10][array.length];
        int[] count = new int[10];
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
        }
        int num = 0;
        while (max != 0) {
            num++;
            max /= 10;
        }
        for (int i = 0, n = 1; i < num; i++, n *= 10) {
            for (int j = 0; j < array.length; j++) {
                int temp = array[j] / n % 10;
                bucket[temp][count[temp]++] = array[j];
            }
            int index = 0;
            for (int i1 = 0; i1 < 10; i1++) {
                for (int j = 0; j < count[i1]; j++) {
                    array[index++] = bucket[i1][j];
                }
                count[i1] = 0;
            }
        }

    }
}

```

## 8、堆排序

参考：https://blog.csdn.net/u010452388/article/details/81283998

1.父结点索引：(*i*-1)/2（这里计算机中的除以2，省略掉小数）

2.左孩子索引：2**i*+1

3.右孩子索引：2**i*+2

```java
//堆排序
public static void heapSort(int[] arr) {
    //构造大根堆
    heapInsert(arr);
    int size = arr.length;
    while (size > 1) {
        //固定最大值
        swap(arr, 0, size - 1);
        size--;
        //构造大根堆
        heapify(arr, 0, size);

    }

}

//构造大根堆（通过新插入的数上升）
public static void heapInsert(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        //当前插入的索引
        int currentIndex = i;
        //父结点索引
        int fatherIndex = (currentIndex - 1) / 2;
        //如果当前插入的值大于其父结点的值,则交换值，并且将索引指向父结点
        //然后继续和上面的父结点值比较，直到不大于父结点，则退出循环
        while (arr[currentIndex] > arr[fatherIndex]) {
            //交换当前结点与父结点的值
            swap(arr, currentIndex, fatherIndex);
            //将当前索引指向父索引
            currentIndex = fatherIndex;
            //重新计算当前索引的父索引
            fatherIndex = (currentIndex - 1) / 2;
        }
    }
}
//将剩余的数构造成大根堆（通过顶端的数下降）
public static void heapify(int[] arr, int index, int size) {
    int left = 2 * index + 1;
    int right = 2 * index + 2;
    while (left < size) {
        int largestIndex;
        //判断孩子中较大的值的索引（要确保右孩子在size范围之内）
        if (arr[left] < arr[right] && right < size) {
            largestIndex = right;
        } else {
            largestIndex = left;
        }
        //比较父结点的值与孩子中较大的值，并确定最大值的索引
        if (arr[index] > arr[largestIndex]) {
            largestIndex = index;
        }
        //如果父结点索引是最大值的索引，那已经是大根堆了，则退出循环
        if (index == largestIndex) {
            break;
        }
        //父结点不是最大值，与孩子中较大的值交换
        swap(arr, largestIndex, index);
        //将索引指向孩子中较大的值的索引
        index = largestIndex;
        //重新计算交换之后的孩子的索引
        left = 2 * index + 1;
        right = 2 * index + 2;
    }

}
//交换数组中两个元素的值
public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

