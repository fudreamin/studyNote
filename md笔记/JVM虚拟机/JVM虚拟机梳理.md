## JVM虚拟机梳理

### 1、什么是JVM？

**JDK**是支持Java程序开发的最小开发环境，其中包括了JRE和编译器和一些工具（jdb、javadoc);

**JRE**是Java运行环境，包括Java虚拟机（JVM）、Java类库、Java命令和一些基础构建，所以JRE可以运行Java字节码文件，但是无法创建和编译。

**JVM**即Java虚拟机，可以将Java字节码转化为机器可以执行的二进制机器码。它针对不同的操作系统有不同的实现，使得使用相同的字节码，在不同操作系统下可以得到相同的结果，屏蔽了操作系统带来的差异，实现了 ”一处编译，随处运行” 。

### 2、JVM内存区域

Java运行时数据区域可以分为五大部分：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中前三者为线程私有区域，后两者为线程共享区域。

**程序计数器**：程序计数器是一块较小的内存区域，可以看作当前线程的所执行字节码的行号指示器。它的工作主要是通过改变计数器的值来选取下一条需要执行的字节码指令。

- 程序计数器是内存区域中唯一不会抛出OutOfMemoryError的区域，生命周期随线程创建而创建，随线程的结束而死亡；
- 如果线程执行的是Java方法，计数器记录的是正在执行的虚拟字节码指令的地址，但如果是本地方法，计数器的值为空；
- 为了保证线程切换后能迅速定位到原来执行的位置，每条线程需要有各自独立且私有的程序计数器。

**虚拟机栈：**每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，都对应着一个栈帧在虚拟机中从入栈到出栈的过程。

- 局部变量表：主要存储编译器可知的Java基本数据类型、对象引用、returnAdress类型（指向一条字节码指令地址）。表中存储空间以局部变量槽（slot）的形式存储。
- 操作数栈：用于计算的临时数据存储区域。

- 虚拟机栈的生命周期也与线程相同。
- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展  ，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

**本地方法栈：**本地方法栈与虚拟机栈基本相同，只不过虚拟机栈服务于Java方法，本地方法栈服务于本地方法。

**堆：**堆是虚拟机中内存最大的一片区域，在虚拟机启动时创建。唯一目的在于存放对象实例，几乎所有的对象实例以及数组都在堆中分配内存。

- Java堆是垃圾收集管理的主要区域，因此也被称为GC堆；
- 当前主流的虚拟机可以对堆进行扩展（通过参数-Xmx和-Xms设定）。如果堆中没有内存可以用来实例分配，并且堆也无法继续扩展时，Java虚拟机会抛出OOM异常。

**方法区**：用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

- 方法区与“永久代”是两个完全不同的概念，并且后者在JDK1.8已经被HotSpot团队完全废除。
- 运行时常量池：运行时常量池是方法区的一部分，里面存放的主要是编译器生成的各种字面量和符号引用。（字面量和符号引用: https://blog.csdn.net/qq_38006520/article/details/83796450)

### 3、垃圾回收机制

#### 3.1 如何判断对象是否死亡？

**引用计数法**：给对象添加一个引用计数器，每当有一个地方引用到就加一，当引用失效，计数器就减一。于是，当引用计数器的值为0时，就代表对象不可能被使用，已经死亡。

引用计数器法简单高效，但也面临着一个很大的问题，如果两个对象相互引用，但是这两个对象并没有其他引用，需要被回收，引用计数器法无法解决循环引用的问题。

**可达性分析算法：**通过GC Roots对象为起点，从这些节点向下搜索，节点所走过的路径被称为引用链，当一个对象没有与任何引用链相连的话，则说明此对象是不可用的。

**GC Roots对象**：

- 虚拟机栈中引用的对象（即局部变量表中引用的对象）
- 本地方法栈中的引用的对象
- 方法区中常量引用的对象
- 所有被同步锁（Synchronized）持有的对象

注：深入了解Java虚拟机中提到的相比之更多，但主要就是这些非堆中对象。

#### 3.2 引用类型

**强引用**：垃圾回收绝不会回收，当内存空间不足，虚拟机宁可抛出OOM错误，使程序异常停止，也不会随意回收强引用对象来解决内存不足问题。

**软引用**：如果内存空间足够，垃圾回收器不会回收它，但是如果内存空间不足，就会回收这些对象的内存。

**弱引用**：弱引用相比软引用拥有更短暂的生命周期，不管当前内存是否足够，垃圾回收器一旦发现了只具有弱引用的对象，都会回收它的内存。不过由于垃圾回收器是一个优先级很低的线程，因此不一定很快发现那些只具有弱引用的对象。

**虚引用**：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

#### 3.3 垃圾回收算法

**标记-清除法**：首先标记出所有不需要的对象，在标记完成后统一回收掉所有没有被标记的对象。虽然简单，但是该方法有两大缺点：

- 执行效率不稳定，可能需要大量标记和清除，导致效率降低；
- 标记清除后会产生大量不连续的内存碎片，浪费空间。

**标记-复制法**：将内存分为大小相同的两块，每次使用其中一块。当这一块内存使用后，就将还存活的对象复制到另一块上，然后再把使用的空间一次清理掉。该方法避免了空间碎片，并且清理更加便捷，但是缺点也很明显，可用内存直接被分成了原来的一半，并且复制也需要消耗时间。

**标记-整理法**：标记过程与标记-清除一致，但是后续是让所有存活对象向一端移动，最后直接清理掉端边界以外的内存。但是对象移动操作需要消耗时间，并且会触发“stop the world"。

**3.4 经典垃圾收集器**：

**1、Serial收集器**

单线程收集器，需要暂停所有工作线程，然后启动GC线程进行垃圾收集，新生代采用标记复制，老年代采用标记整理，等垃圾收集完毕，才可以重新运行工作线程。

stop the world时间过长，但是简单高效，没有线程交互开销，单核或少核环境收集效率高。

**2、ParNew收集器**

实质上是Serial的多线程版本，在垃圾收集过程中，采用多线程进行垃圾收集（注意只是垃圾收集时多线程，并不是和用户线程并行，所以仍然会有stop the world。新生代标记复制，老年代标记整理。

**3、Parallel Scavenge收集器**

与ParNew基本一致，但是Parallel Scavenge关注的是吞吐量（高效率利用CPU），即CPU运行代码时间和CPU总消耗时间比值。提供了很多参数供用户找到合适的停顿时间和最大吞吐量。

**4、CMS收集器**

以获取最短回收停顿时间为目标的收集器。首次实现了垃圾收集线程和用户线程同时工作。采用的是标记清除算法。

步骤：

1. 初始标记：暂停所有其他线程，并记录与root相连的对象，速度很快；
2. 并发标记：同时启动GC和用户线程，GC线程从GC Roots遍历整个对象图，虽然用时长但不需要暂停用户线程；
3. 重新标记：同样需要暂停其他线程，修正并发标记期间因为用户线程继续运行导致产生变动的那一部分对象标记记录。一般时长长于初始标记，但是远比并发标记短；
4. 并发清除：开启用户线程，同时GC线程开始对未标记区域做清扫。

**5、G1收集器**

针对多处理器、大内存机器，在满足停顿时间的基础上，还具备高吞吐量等特征。基于标记-整理。

1. 初始标记                      
2. 并发标记
3. 最终标记
4. 筛选回收

### 4、类加载机制

一个类的完整生命周期：加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备、解析统称为连接。

#### 4.1 加载

通过类的全限定类名来生成一个Class对象，全限定类名可以从多个渠道获取（网络、压缩包、数据库等文件）

#### 4.2 验证

#### 4.3 准备

#### 4.4 解析

#### 4.5 初始化

#### 4.6 卸载