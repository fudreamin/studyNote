# 面经

1、Java基础

**finally的执行时间是：retrun表达式执行之后，在return返回操作之前。**

2、Java框架

3、多线程

4、MySQL

串行化解决幻读问题策略：

- 事务在读操作时，先加表级别的共享锁，直到事务结束才释放
- 事务在写操作时，先加表级别的排它锁，直到事务结束才释放

5、Redis

**三种过期策略**

- 定时删除
  - 含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除
  - 优点：保证内存被尽快释放
  - 缺点：
    - 若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key
    - 定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重
    - 没人用
- 惰性删除
  - 含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
  - 优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）
  - 缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）
- 定期删除
  - 含义：每隔一段时间执行一次删除过期key操作
  - 优点：
    - 通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理"定时删除"的缺点
    - 定期删除过期key--处理"惰性删除"的缺点
  - 缺点
    - 在内存友好方面，不如"定时删除"
    - 在CPU时间友好方面，不如"惰性删除"
  - 难点
    - 合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了

**缓存失效：**

​	1.因为打到内存阀值，采用数据淘汰策略（LRU/LFU）导致数据失效。

​	2.数据设置了过期时间，达到过期时间后，数据失效。

​	3.因为故障或者宕机/升级，导致服务重启，数据失效。

6、数据结构

7、计算机网络