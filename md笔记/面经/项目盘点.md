# 项目盘点

#### 1、MD5加密

MD5加密算法可以保证加密后的数据没有办法逆向解密，但是，如果数据使用的是相对简单的字符串，仍然可能被他人通过MD5字典库进行匹配来达到解密效果。而此时可以通过加盐（即对MD5摘要结果掺入其他信息）：

MD5加密后为128位（bit），按照16进制（4位一个16进制数）编码后，就成了32个字符。MD5并不是加密算法，而是摘要算法。加密算法是可逆的，摘要算法是理专论上不可逆的。

而我们每次保存密码到数据库时，都生成一个随机16位数字，将这16位数字和密码相加再求MD5摘要，然后在摘要中再将这16位数字按规则掺入形成一个48位的字符串。在验证密码时再从48位字符串中按规则提取16位数字，和用户输入的密码相加再MD5。按照这种方法形成的结果肯定是不可直接反查的，且同一个密码每次保存时形成的摘要也都是不同的。

#### **2、基于token的分布式会话实现登录**

**步骤：**当我们在进行登录操作时，后端将前端传输过来的账号密码与数据库进行匹配，如果匹配成功，则通过UUID生成器生成一个随机token，并且**将这个token设定好过期时间保存到Redis中**，然后将这个token传回前端，前端将token保存到localStroage中，之后每次进行请求都携带这个token给后端验证，这样子就完整的实现了登录功能。

**注意：**

1. 为什么要保存在Redis中？如果只是单纯的使用服务器进行保存，在分布式系统中只能在一个服务器中保存token，系统每次服务器轮询不可能一直在这个服务器；
2. localStroge相比与Cookie可以存储更大的信息量，并且相比于Session它可以一直保存在浏览器中（除非主动清除），而Session只能在当前会话中生效，关闭会话或者浏览器的话Session就会被清除。

#### 3、Guava Cache 和 Redis

- Guava为本地缓存，而Redis为分布式缓存，同时使用可以通过多级缓存来降低数据命中MySQL数据库的概率，提高并发量；
- 本地缓存：指的是在应用中的缓存组件，其最大的优点是应用和cache在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较为合适；同时，它的缺点也是因为缓存跟应用程序耦合，多个应用程序无法直接共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费；
- 分布式缓存：指的是与应用分离的缓存组件或服务，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接共享缓存。

- 综上：Redis相比于Guava Cache可以实现多个应用之间缓存的共享，但相比之下速度就不如与应用在同一个进程的Guava Cache了。

#### 4、秒杀令牌和队列泄洪

**秒杀令牌：**

- 令牌生成：秒杀令牌在判断所有校验条件无误后生成，只有持有秒杀令牌才可以参与秒杀，这样子可以阻止不合法用户参与秒杀以及用户在活动开始前就不停点击；
- 秒杀大闸：通过限制秒杀令牌的数量，控制实际参与秒杀的人数。

**队列泄洪：**

- 对于秒杀时期流量洪峰的问题，使用线程池只提供一定数量的线程来进行操作，剩下的任务需要在等待队列中等待，以此来限制并发数量。

#### 5、RocketMQ

https://www.cnblogs.com/terry-love/p/11492397.html、

#### 6、缓存与数据库数据一致性

缓存能缩短服务的响应时间，增大系统的吞吐量，减轻数据库的压力，但与此同时，缓存与数据的一致性也成为了新的问题。

**更新缓存还是删除缓存**

假设我们采取更新缓存，我们假设有A、B两条线程的情况

1. 线程A更新了数据库
2. 线程B更新了数据库
3. 线程B更新了缓存
4. 线程A更新了缓存

明明A先更新数据库，B却比A更早更新了缓存，这时候就导致了脏数据的出现，删除缓存只会增加一次cache miss，但能在一定程度上避免安全问题，所以我们应当采用删除缓存。

**先删除缓存，还是先操作数据库？**

在非并发情况下：

- 假设先操作数据库，我们将数据库中对应的行进行改变，但是在删除缓存的时候出现问题，就会导致数据不一致。
- 假设先删除缓存，再操作数据库，第一步删除缓存成功，然后再写入数据库时失败，数据依然一致，知识会产生一次Cache miss。

当然，前提只是非并发条件，如果是并发条件，仍然可能出现问题：

1. 请求A进行写操作，删除缓存
2. 请求B查询缓存不存在
3. 请求B去数据库查询得到旧值
4. 请求B将旧值写入缓存
5. 请求A将新值写入数据库

可以看出，在并发条件下，即使先删除缓存，再操作数据库仍然可能出现问题。

**延时双删**

1. 先淘汰缓存
2. 再对数据库进行写操作
3. 休眠一秒，再次淘汰数据库

具体“一秒”需要根据业务需求而定。

可以看出，再这一秒内，仍然可能出现数据不一致，但大多数情况可以接受。

