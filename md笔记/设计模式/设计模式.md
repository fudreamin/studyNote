# 设计模式

## 1、单例模式

首先，什么是单例模式？单例模式是为了保证某一个类只有一个实例，并且提供一个访问他的入口。

- 单例类只能有一个实例；
- 单例类必须自己创建自己的唯一实例；
- 单例类必须给所有其他对象提供这一实例。

### 1、饿汉式单例

顾名思义，对于饿汉式单例，希望的是可以在需要时直接取到对象，所以在类加载时就初始化了对象。但也正因为如此，就算完全没调用过该方法依然会消耗内存，容易产生垃圾对象。

在线程安全方面，因为反复调用的都是同一个对象，所以虽然该单例并没有加锁，但仍然保证了线程的安全性。

```java
//饿汉式单例
public class Hungry {
    private Hungry() {
        System.out.println(Thread.currentThread().getName()+"run...");
    }

    private static final Hungry hungry = new Hungry();

    public static Hungry getInstance() {
        return hungry;
    }

}
```

### 2、懒汉式单例（双重校验锁）

对于懒汉式单例，只有当需要获取对象时才会初始化对象，为了保证线程安全问题，必须通过加锁来防止线程不安全的情况。而双重校验锁的第一重校验其实是为了提高程序运行性能，如果已经检测到lazyMan不为空，那就没必要为其加锁，直接返回当前lazyMan即可，但是，如果检测到lazyMan为空，在多线程的环境下我们并不能保证此时lazyMan真的没有被初始化过，所以需要加锁进行第二重校验。

```java
public class LazyMan {


    private LazyMan() {
        System.out.println(Thread.currentThread().getName() + " run");
    }

    private static volatile LazyMan lazyMan;

    public static LazyMan getInstance() {
        if (lazyMan == null) {
            synchronized (LazyMan.class) {
                if (lazyMan == null) {
                    lazyMan = new LazyMan();
                    return lazyMan;
                }
            }
        }
        return lazyMan;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                System.out.println(LazyMan.getInstance());
            }, String.valueOf(i)).start();
        }
    }
}
```

### 3、IoDH实现单例模式

(**Initialization Demand Holder**)

通过静态内部类的IoDH实现单例方式，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能。不过，IoDH最大的缺点在于很多面向对象语言不支持IoDH。

```java
public class HolderSingleton {
    private HolderSingleton() {

    }

    private static class Holder{
        private static final HolderSingleton holderSingleton = new HolderSingleton();
    }

    private static HolderSingleton getInstance(){
        return Holder.holderSingleton;
    }
}

```

### 4、枚举实现单例 

前面三种方法虽然都基本实现了单例模式，但都存在一个很容易被忽略的问题——反射，想要避免反射操纵的问题，就必须再添加额外代码，而枚举却不会受反射影响。

```java
public enum EnumSingleton {
    INSTANCE;

    public EnumSingleton getInstance(){
        return INSTANCE;
    }

}
```

## 2、工厂模式

参考：https://blog.csdn.net/qq_36186690/article/details/82945749

相比复杂的工厂模式，直接new不是更快么，甚至很多时候，我们可以使用一个类通过构造函数和方法的重载来实现所有功能，简单粗暴，不香么？

那么，为什么我们还要用工厂模式？

1. 解耦，很多时候，我们需要把对象的创建和使用分离。Class A 想调用 Class B ，那么A只是调用B的方法，而至于B的实例化，就交给工厂类，而不用关心B的具体实现。通过工厂模式我们不需要了解创建B的任何信息。
2. 降低代码复杂度，如果创建对象B的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。我们可以这些创建对象B的代码放到工厂里统一管理。既减少了重复代码，也方便以后对B的创建过程的修改维护。
3. 另外工厂模式还有一个用途：取代构造函数的重载。使用工厂模式比重载构造方法更灵活，构造方法必须使用类名进行重载，而工厂模式可以给功能更明确的定义，并且，工厂方法可以支持相同参数的使用（比如身高体重）

工厂模式优点：

- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；
- 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；

### 1、简单工厂模式

简单工厂模式实现简单，但是违反了开闭原则，对扩展开放，对修改关闭，而简单工厂需要添加新的实现类必须修改工厂类。

```java
//抽象类
public interface Car {
    void name();
}
//工厂类
public class CarFactory {
    public static Car getCar(String car){
        if("五菱".equals(car)){
            return new Wulin();
        }else if("特斯拉".equals(car)){
            return new Tesla();
        }else{
            throw new RuntimeException("暂时无法制造");
        }
    }
}
//实现类
public class Tesla implements Car{
    @Override
    public void name() {
        System.out.println("特斯拉");
    }
}
//实现类
public class Wulin implements Car{
    @Override
    public void name() {
        System.out.println("五菱宏光");
    }
}
//消费者
public class Consumer {
    public static void main(String[] args) {
        //需要知道接口和所有实现类
        Car car1 = new Wulin();
        Car car2 = new Tesla();
        car1.name();
        car2.name();
        //使用简单/静态工厂方法,但违反开闭原则
        Car car=CarFactory.getCar("五菱");
        car.name();

    }
}

```

### 2、工厂模式

工厂模式相比简单工厂而言，更加复杂，但保证了开闭原则。

```java
public interface Car {
    void name();
}
public interface CarFactory {
    Car getCar();
}
public class TeslaFactory implements CarFactory {

    @Override
    public Car getCar() {
        return  new Tesla();
    }
}
public class WulinFactory implements CarFactory {

    @Override
    public Car getCar() {
        return new Wulin();
    }
}
public class Tesla implements Car {
    @Override
    public void name() {
        System.out.println("特斯拉");
    }
}
public class Wulin implements Car {
    @Override
    public void name() {
        System.out.println("五菱宏光");
    }
}
public class Volkswagen implements Car {
    @Override
    public void name() {
        System.out.println("大众汽车");
    }

}
public class VolkswagenFactory implements CarFactory{
    public Car getCar() {
        return new Volkswagen();
    }
}
public class Consumer {
    public static void main(String[] args) {
        Car car1 = new WulinFactory().getCar();
        Car car2 = new TeslaFactory().getCar();

        car1.name();
        car2.name();

        Car car3 = new VolkswagenFactory().getCar();
        car3.name();
    }
}
```

## 3、抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。抽象工厂相比工厂模式多了一个产品集的概念。

```java
public interface Phone {
    void start();

    void shutdown();

    void message();

    void call();
}

public interface Computer {
    void game();

    void movie();

}

public interface ProductFactory {
    Phone getPhone();

    Computer getComputer();
}

public class HuaweiComputer implements Computer{
    @Override
    public void game() {
        System.out.println("华为电脑打游戏");
    }

    @Override
    public void movie() {
        System.out.println("华为电脑看电影");
    }
}

public class HuaweiFactory implements ProductFactory {
    @Override
    public Phone getPhone() {
        return new HuaweiPhone();
    }

    @Override
    public Computer getComputer() {
        return new HuaweiComputer();
    }
}

public class HuaweiPhone implements Phone{

    @Override
    public void start() {
        System.out.println("华为手机开机");
    }

    @Override
    public void shutdown() {
        System.out.println("华为手机关机");
    }

    @Override
    public void message() {
        System.out.println("华为手机发信息");
    }

    @Override
    public void call() {
        System.out.println("华为手机打电话");
    }
}

public class MiComputer implements Computer {
    @Override
    public void game() {
        System.out.println("小米电脑打游戏");
    }

    @Override
    public void movie() {
        System.out.println("小米电脑看电影");
    }
}

public class MiFactory implements ProductFactory{

    @Override
    public Phone getPhone() {
        return new MiPhone();
    }

    @Override
    public Computer getComputer() {
        return new MiComputer();
    }
}

public class MiPhone implements Phone {

    @Override
    public void start() {
        System.out.println("小米手机开机");
    }

    @Override
    public void shutdown() {
        System.out.println("小米手机关机");
    }

    @Override
    public void message() {
        System.out.println("小米手机发送信息");
    }

    @Override
    public void call() {
        System.out.println("小米手机打电话");
    }
}

public class Consumer {
    public static void main(String[] args) {
        Computer computer = new HuaweiFactory().getComputer();
        computer.game();
    }
}
```

