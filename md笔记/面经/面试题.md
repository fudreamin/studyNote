#### 1、三次握手四次挥手

首先，三次握手四次挥手都发生在计算机网络的传输层，而三次握手四次挥手就是TCP为了建立一个面向连接的可靠的数据流传输。

三次握手的目的就是为了保证客户端知道服务端能接收自己的数据，并且服务端也知道客户端能接收到自己的数据。

客户端发送SYN位置1的数据包给服务端，服务端发送SYN位、ACK位置1的数据包给客户端。客户端再发送ACK位置1的数据包给服务端。

而四次挥手的过程是，客户端准备断开连接，所以发送FIN位置1的数据包给服务端，服务端回复客户端ACK位置1的数据包，但是此时服务端可能还有没有发送完的数据，所以必须发送完数据后，再发送一个FIN位置1的数据包给客户端，最后客户端回复ACK位置1的数据包。（如果等发送完数据再发送ACK包，客户端可能以为服务端没有接受到自己的断开连接请求，重复发送断开连接请求）

#### 2、MySQL索引

索引（Index）是帮助MySQL高效获取数据的数据结构。所以归根结底，索引依然是一种数据结构。索引能大大提升对数据的查询能力，但是，为了维持索引，对于表的更新速度就会有所降低。

**MYSQL索引的底层是B+树**，B+Tree与B-Tree 的区别：

1. B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。　
2. 在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+树的性能可能还会好些，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。 

为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？

1.  B+树的磁盘读写代价更低 。B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
2.  B+树的查询效率更加稳定 。由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
3.  B树**范围查找**要中序遍历，B+树顺着链表遍历。B+树相比B树可以减少磁盘io。

**聚簇索引和非聚簇索引**：对于聚簇索引，表中数据的逻辑顺序和物理顺序是相同的，而对于非聚簇索引，逻辑顺序和物理顺序并不需要相同。聚簇索引更像字典里的按拼音查找，而非聚簇索引更像字典里的按部首或者笔画查找。

聚簇索引的好处：按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不不用从多个数据块中提取数据，所以节省了大量的io操作。

注意：聚集索引由于索引叶节点就是数据页，所以如果想检查主键的唯一性，需要遍历所有数据节点才行，但非聚集索引不同，由于非聚集索引上已经包含了主键值，所以查找主键唯一性，只需要遍历所有的索引页就行（索引的存储空间比实际数据要少），这比遍历所有数据行减少了不少IO消耗。这就是为什么主键上创建非聚集索引比主键上创建聚集索引在插入数据时要快的真正原因。

**索引分类**：

单值索引：即一个索引只包含单个列，一个表可以有多个单列索引。

主键索引：设定为主键后数据库会自动建立索引，innodb为聚簇索引。

唯一索引：索引列的值必须唯一，但允许有空值。

复合索引：即一个索引包含多个列。

**索引覆盖和回表：**

回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。

索引覆盖：既通过使用主键索引或者只查询索引包含的字段来避免回表查询，就可以触发索引覆盖。

#### 3、Spring IoC和AOP

IoC（Inverse of Control:控制反转）:IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。

AOP(Aspect-Oriented Programming:面向切面编程):能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib生成一个被代理对象的子类来作为代理。

#### 4、Spring MVC工作流程

1. 客户端（浏览器）发送请求，直接请求到 `DispatcherServlet`。
2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。
3. 解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由 `HandlerAdapter` 适配器处理。
4. `HandlerAdapter` 会根据 `Handler `来调用真正的处理器来处理请求，并处理相应的业务逻辑。
5. 处理器处理完业务后，会返回一个 `ModelAndView` 对象，`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
6. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。
7. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。
8. 把 `View` 返回给请求者（浏览器）

#### 5、MyBatis

 **$ 和 # 区别以及原理:**

1. \#可以防止Sql 注入，它会将所有传入的参数作为一个字符串来处理。
2. $ 则将传入的参数拼接到Sql上去执行，一般用于表名和字段名参数，$ 所对应的参数应该由服务器端提供，前端可以用参数进行选择，避免 Sql 注入的风险

#### 6、SpringBoot

SpringBoot之于Spring的优势:

1. SpringBoot省去了大量的XML配置，可以快速搭建项目；
2. SpringBoot内置了Tomcat，省去自己配置Tomcat的过程。

**SpringBoot自动装配**：

- 什么是自动装配：SpringBoot定义了一套规范，在SpringBoot启动时会自动扫描外部引用jar包中META-INF/spring.factories文件，然后将文件中配置的类型信息自动加载到Spring容器中。这样子我们就无需手动繁琐的配置第三方的依赖，直接在项目中引入对应的starter即可。

- 原理：SpringBoot自动装配的核心注解就是@SpringBootApplication，而这个注解点开后能看三个派生注解：

  - @SpringBootConfiguration：主要作用是标志配置类，允许在上下文中注册额外的Bean或者导入其他配置类；
  - @ComponentScan：扫描被@Component注解的Bean;
  - @EnableAutoConfiguration：启用SpringBoot自动注解机制。

  @EnableAutoConfiguration只是一个简单的注解，自动装配的核心功能主要是通过AutoConfigurationImportSelector类，该类实现了ImportSelector接口的SelectImports方法，该方法可以获取所有符合条件的类的全限定类名，并且将这些类加载到Spring容器中。

[参考](https://www.cnblogs.com/javaguide/p/springboot-auto-config.html)

#### 7、集合框架

另见其他笔记。

#### 8、HTTP请求过程

1. 域名解析：浏览器DNS缓存 -> 本地DNS缓存 -> 本地hosts文件 -> 运营商DNS；
2. 三次握手：根据TCP协议发起三次握手建立连接；
3. 发送请求：经过TCP3次握手之后，浏览器发起了http的请求；
4. 响应请求：服务器端响应http请求，浏览器得到html代码；
5. 解析代码：浏览器解析html代码，并请求html代码中的资源；
6. 渲染页面：浏览器对页面进行渲染呈现给用户。

#### 9、IO流

https://www.cnblogs.com/yichunguo/p/11775270.html#1%E3%80%81%E5%91%8A%E7%99%BDio%E6%B5%81%E7%9A%84%E5%9B%9B%E7%82%B9%E6%98%8E%E7%A1%AE

#### 10、多线程

**线程和进程：**进程是系统进行资源分配和调度的基本单位，系统中正在运行的一个应用程序，就是一个进程；而线程是操作系统能够进行运算调度的最小单位，也就是程序执行的最小单位，它被包含在进程之中。进程与进程之间的资源是独立的，进程拥有自己独立的资源空间，而同一个进程内的线程共享这个进程的资源。

**并发和并行**：并发是同一时间段内，多个任务都在进行（但单位时间内不一定都在执行）；但并行是单位时间内，多个任务同时执行。

**线程生命周期：**NEW、RUNNABLE、BLOCKED、WATING、TIMED_WATING、TERMINATED。“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生：而“等待状态”则是在等待一段时间，或者唤醒动作发生。在程序等待进入同步区域的时候，线程将进入这种状态。

**多线程的实现：**继承Thread类、实现Runnable接口、实现Callable接口以及线程池。(对于继承Thread类和实现接口而言，由于Java中只允许单继承，如果通过继承Thread来实现多线程，就意味着该类无法再继承其他类，而Java支持一个类实现多个接口，避免了单继承的局限性，因此使用实现接口的方法要优于继承Thread类。其次，如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享)。

**线程间通信：**

- wait - notify；
- volatile；
- CountDownLatch，在CountDownLatch值等于0前不会执行主线程。
- 通过Semaphore信号量，先设置一个负值，当信号量到1时，再执行主线程.

**进程间通信：**

- 管道
- 信号量
- 消息队列
- socket

**如果等待子线程执行完后在执行主线程：**

- join()：通过将子线程join到主线程，主线程会等子线程执行完后在执行join之后的部分；
- CountDownLatch：通过await()方法，主线程会等待CountDownLatch类的值到0后再执行之后的操作；
- Future： Future的get()方法会使得主线程等到获取到线程结束返回的结果再执行之后的操作。

#### 11、线程池

**优点：**

- **降低资源消耗**：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**：当任务到达时，可以不需要等待线程创建就能立即执行。
- **提高线程的可管理性**：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，监控和调优。

**自定义线程池七大参数：**

- **corePoolSize**：线程池中的常驻核心线程数。
- **maximumPoolSize**：线程池中能够容纳同时执行的最大线程数，此值必须大于等于1。
- **keepAliveTime**：多余的空闲线程的存活时间当前池中线程数量超过corePoolSize时，当空闲时间
  达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止。
- **unit**： keepAliveTime的单位 。
- **workQueue**：任务队列，被提交但尚未被执行的任务。
- **threadFactory**：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可。
- **handler**：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略。
  1. AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行.
  2. CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不
     会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。
  3. DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中
     尝试再次提交当前任务。
  4. DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。
     如果允许任务丢失，这是最好的一种策略。

**线程池工作流程：**

1. 刚创建线程池后，线程池内线程数量为0；
2. 添加任务时，如果当前线程池内线程数量小于核心线程数，线程池会创建新的线程来运行该任务；
3. 如果当前线程池内线程数量大于核心线程数且小于最大线程数，线程池会将该任务放入任务队列；
4. 如果此时任务队列已满，但线程池内线程数量仍然小于最大线程数，线程池会创建非核心线程来运行该任务；
5. 如果此时任务队列已满，且正在运行的线程数量大于或等于最大线程数，线程池会启动饱和拒绝策略；
6. 当一个线程执行完任务后，它会从任务队列取出下一个任务执行；
7. 当一个线程无事可做超过空闲线程存活时间时，它会判断当前运行的线程数量是否大于核心线程数量，如果大于，那么这个线程就会被停掉。

**四大常用线程池：**

- **CachedThreadPool** ：核心线程数为0，最大线程数为Integer. Max_Value()，可以近乎无限创建线程;
- **SingleThreadExecutor** ：核心线程数为1，最大线程数为1，队列为链表，所以可以达到有序执行线程的效果；
- **FixedThreadPool** ：核心线程数固定，最大线程数等于核心线程数，可以固定线程数量，但执行到最后线程不会自动回收。
- **ScheduledThreadPool**：定时或定期执行任务。

**Executors 返回线程池对象的弊端如下：**

- **FixedThreadPool** 和 **SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。
- **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。

#### 12、Volatile

**Java内存模型（JMM）**：描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量，存储到内存和从内存中读取变量这样的底层细节。归根结底，出现JMM的原因是因为对于现代计算机而言，CPU和内存的处理数据速度之间存在极大差异。为了平衡这一差异，于是就通过高速缓冲区来作为内存和CPU之间的缓存。但这也就到来了数据一致性的问题，于是JMM作为规则出现。所有共享变量的值保存在主内存中，工作线程持有主内存变量的副本。

**线程的三大特性**：可见性、原子性、有序性。

1. **可见性**：volatile通过总线嗅探机制保证了多线程之间的可见性，对于被volatile修饰的变量，在工作线程中的副本会不断嗅探总线中变量的值，如果总线中变量的值发生改变，副本中的变量会失效，然后从总线中重新获取。
2. **原子性：**volatile作为轻量级同步工具，并不能保证原子性。
3. **有序性：**volatile通过生成内存屏障禁止了指令重排，注意，volatile会生成两个内存屏障，对于读操作，会直接将内存屏障全部放在代码后面，而对于写操作，会分放在前后两侧。

#### 13、AQS

AQS

#### 14、GET和POST

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

#### 15、MySQL日志

MYSQL有六种日志文件：重做日志（redo log）、回滚日志（undo log）、二进制日志（bin log）、错误日志（error log）、慢查询日志（slow query log）、一般查询日志（general log）、中继日志（relay log）

**bin log**： bin log是MySQL服务层上维护的二进制日志，与innodb引擎上的redo/undo 日志是作用层级完全不同。主要用于记录MYSQL的数据更新。主要用于数据库的主从复制、数据库恢复等场景。

- bin log不会记录也没有必要记录不发生修改的语句，如show、select；
- bin log会重写日志中的密码，保证不会以纯文本形式出现。

**redo log**：如上所说，redo log存在于innodb引擎，主要用于保证数据的持久性。innodb在将事务提交到缓存前会先保存到redo log中，所以即使缓存持久化到磁盘中失效，也可以采用redo log进行重试，直到保存成功，从而保证事务一旦提交，就永久的保存到了数据库中。bin log和redo log都可以用来做数据库恢复。

**undo log**： undo log主要用于事务回滚来保证一致性和MVCC实现事务不可重复读、可重复读两个隔离级别。

#### 16、Redis持久化

**持久化原因**：Redis数据储存在内存中，如果服务器进程退出或者系统停机，Redis服务中的数据会丢失，所以需要将内存中的数据保存再磁盘中以此来防止数据丢失。

**什么是RDB**：RDB就是将某个时间点的Redis中的数据保存在一个RDB（默认dump.rdb)文件中，该文件是一个二进制压缩文件，可以通过该文件还原出生成RDB文件时Redis的数据。

**创建RDB文件：**

1. SAVE命令：阻塞Redis服务器进程，直到Redis文件创建完毕，再服务器进程阻塞期间，服务器不能处理任何请求命令；

2. BGSAVE命令：派生出一个子进程，由子进程负责创建RDB文件。我们可以手动执行该命令，但更推荐通过设置Redis配置文件（redis.conf）来执行。默认有三个保存条件：save 900 1  save 300 10  save 60 10000，save a b 表示在a秒内进行了b次修改就执行BGSAVE命令，而多个条件只需要满足一个便会触发命令。

   注：我们可以在配置文件中更改生成的rdb文件名：dbfilename dump.rdb

**载入RDB文件：**

1. Redis载入RDB文件没有专门的命令，而是在Redis启动时自动执行；
2. 只有在AOF持久化功能处于关闭状态（AOF功能默认关闭），服务器才会用RDB文件来还原数据，否则服务器会优先使用AOF来进行文件还原；
3. 需要注意的是，服务器在载入RDB文件过程中，会一直处于阻塞状态，知道RDB文件载入成功。

**什么是AOF**：AOF是通过保存Redis服务器所执行的写命令来记录数据库数据的，这些写命令被保存到了.aof中。

**打开AOF功能**：AOF持久化功能默认是关闭的，需要在配置文件中将appendonly no修改为 appendonly yes 。与RDB相同，你可以通过appendfilename "appendonly.aof" 来修改默认aof文件名。

**AOF持久化功能的实现：**当AOF文件持久化功能处于打开状态时，Redis服务器在执行完一个写命令后，会以议协议格式将被执行的写命令追加到服务器的AOF缓冲区的末尾，然后服务器会根据配置文件中appendfsync选项的值来决定何时将AOF缓冲区中的内容写入和同步到AOF文件中。appendfsync选项：

1. always：即使出现故障停机，最多丢失一次操作的数据，安全性很好。但是，服务器在每个事件循环都要将AOF缓存中的所有内容都写入到AOF文件中，并且同步AOF文件，效率很低。
2. everysec（默认）：服务器在每个事件循环都要将AOF缓存中的所有内容都写入到AOF文件中，并且每隔一秒就要在子线程中对AOF文件进行同步。
3. no：服务器在每个事件循环都要将AOF缓存中的所有内容都写入到AOF文件中，但是具体同步时间有操作系统控制，效率与everysec差不多。
4. 注意：写入的意思将缓冲区已有数据写入磁盘中，但是，是不是真的已经写入我们并不关注；而同步就是确确实实将数据冲洗到了磁盘上。所以同步操作是比较消耗时间的，这也是为什么AOF默认采用everysec的一个原因。

详细细节参考：https://www.freesion.com/article/6440202770/

写入和同步意思：https://blog.csdn.net/umdcoding/article/details/52328624

**载入AOF文件**：因为AOF文件包含了数据库所需的所有写命令，所以Redis服务器只需要读入并重新执行一遍AOF文件中的所有命令就可以还原Redis服务器关闭前的数据。详细步骤：

1. 创建一个不带网络连接的伪客户端（显然，载入命令并不需要用到网络连接）
2. 从AOF文件中分析并读取出一条命令
3. 使用伪客户端执行读取出的命令
4. 重复执行2、3操作，直至AOF文件中的所有写命令被执行完毕。

**AOF重写**：AOF持久化是通过保存被执行的命令来记录数据库数据，所以，AOF文件的体积一般来说是不断增大的，但其实这些命令中的一部分是重复冗余或者已经被覆盖的，我们不希望被这一部分命令占用磁盘空间进而导致数据还原时间过长。于是就有了AOF重写，重写的实现原理其实就是：

- 通过从数据库中读取键现在的值，然后用一条命令记录键值对，代替之前这个键值对的多条命令。
- AOF重写是通过使用子进程来执行的，所以在服务器进行AOF重写期间，服务器进程可以继续处理请求命令

**重写步骤**：

1. 服务器创建子进程，子进程开始AOF文件重写

2. 从创建子进程开始，服务器进程执行的写命令不仅要写入AOF缓冲区，还要写入AOF重写缓冲区

   - 写入AOF缓冲区的目的是为了同步到原有的AOF文件，使得重写期间服务器仍然可以处理请求。
   - 写入到重写缓冲区的目的是因为子进程重写期间，服务器进程还在继续处理命令请求，而新的命令可能对现有的数据库进行修改从而使得服务器当前的数据库数据和重写后的AOF文件所保存的数据库数据不一致。

3. 子进程完成AOF重写工作，向父进程发送一个信号，父进程收到信号后，会执行：

   1. 将AOF重写缓冲区中的所有内容写入到新的AOF文件中，这样就保证了新AOF文件所保存的数据库数据和服务器当前数据库数据是一致的。
   2. 对新的AOF文件进行改名，原子覆盖现有的AOF文件，完成新旧AOF两个文件的替换。

   注：Redis提供了BGWRITEOF操作来手动执行重写操作。

#### 17、HTTPS加密

**为什么需要加密**：http传输数据是通过明文传输，明文数据会通过中间代理服务器、路由器、wifi热点、通信运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了，更有甚者，劫持者可以篡改劫持的信息且不被双方查询（中间人攻击）。

**对称加密：** 同一个密钥既可以对数据进行加密，也可以进行解密。服务器先通过明文传输该密钥给浏览器，浏览器接收到后，双方就同时拥有了该密钥，都可以对数据进行加密并传输给对方。但是，正因为通过明文传输该密钥，传输过程中很容易被他人截获，进而通过该密钥破解之后传输的数据。

**非对称加密**：通过两个密钥——公钥和私钥，公钥只能破解私钥的数据，私钥只能破解公钥的数据。服务器先将公钥发送给浏览器，浏览器用公钥加密数据后将数据传回给服务器，劫持的人虽然有公钥但无法破解公钥加密的内容，这样子就可以保证浏览器发送的数据没有办法被其他人破解（暂时抛开中间人攻击不谈）。但是，当服务器需要发送数据给客户端时，劫持人已经拥有公钥了，所以对于服务器用私钥加密的数据依然无法保证安全。

**改良后的非对称加密：**既然一对公私钥没有办法解决，那就用两对，浏览器一对，客户端一对，这样子就能避免非对称加密造成的服务器私钥加密数据被破解了。该方法虽然保证了安全层面的问题，但是，非对称加密算法相比对称加密算法是相当耗费时间的，我们依然希望能够通过一次非对称加密解决问题。

**非对称加密+对称加密**：服务器拥有非对称加密公钥A和私钥A，而浏览器拥有对称加密密钥B。于是，服务器先将公钥A明文传输给浏览器，浏览器拿到后，用A对密钥B进行加密，然后传回给浏览器，于是，服务器通过私钥A解密数据后就可以得到密钥B。这样一来，似乎就可以只通过一次私钥加密就能保证服务器和浏览器都拥有密钥B，且其他人无法捕获这个密钥。

**中间人攻击**：我们再对上述的方案进行一次推导，但是这次，服务器和浏览器之间加入了一个能够劫持铭文数据的中间人。

1. 服务器将公钥A明文传输，被中间人捕获，中间人保留公钥A，并用一个自己的公钥X替代公钥A发送给浏览器
2. 浏览器收到公钥X后，用X对密钥B加密后传输，但传输过程中再次被中间人截获，中间人解密后拿到X，再将X用公钥A加密X后发回给服务器
3. 从此时期，中间人拿到了公钥A和传输数据时所使用的密钥X，也就是说，以上所有的加密方式都存在一定问题。

**数字证书：**网站在使用HTTPS前，需要向CA机构申领一份电子证书，证书里含有证书持有者信息（域名等）、公钥信息等。

**每次HTTPS请求都需要加密？**服务器会为每个浏览器维护一个session ID，在TSL握手阶段生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID中，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行加密解密操作，这样就不必要重新制作、传输密钥了。

#### 18、Java死锁

**死锁产生四大条件**：互斥条件、请求和保持条件、不剥夺条件、环路等待条件。

1. **互斥条件：**进程对所分配到的资源进行排他性控制，一段时间内某资源仅为一个进程所占有；

2. **请求和保持条件：**一个进程因请求被占用资源导致阻塞时，对已获得的资源保持不放；

3. **不剥夺原则：**任何一个资源在没被进程释放前，任何进程都无法对他剥夺占用；

4. **环路等待条件：**当发生死锁时，锁等待的进程必定形成一个环路。

**解除死锁方法**：

1. 破坏请求和保持条件：
   - 所有进程开始之前，必须一次性申请自己运行时需要的所有资源，这样就不会出现请求时需要的资源被占用。但是也很容易出现因为资源被占用，进程无法启动，造成饥饿现象，严重降低了资源利用率；
   - 对于上一种方法，我们可以让他请求到运行期初期所需资源就启动进程，然后在运行期间逐步释放自己所使用完毕的资源，然后再去请求新的资源。这样子就可以提高资源的利用率，并且降低饥饿的概率。
2. 破坏不剥夺条件：当一个持有资源的进程请求资源没有得到满足时，他需要放弃自己所拥有的全部资源，待以后需要的时候再重新申请，这样子就可以达到类似”被抢占“的效果。但是，很明显的可以看出，这是一个需要极大代价的方法，反复的申请和释放会浪费大量时间。
3. 破坏环路等待条件：可以通过定义资源的线性顺序来实现，为所有资源编号，当进程持有编号为i的资源时，他只能去请求编号大于i的其他资源。虽然避免了循环等待，但是也会出现明明资源没被占用，却因为编号原因被拒绝访问的尴尬，资源使用被降低。
4. 对于互斥条件，通常来说我们并不会去破坏，因为多数加锁的情况就是为了达成互斥。

#### 19、MySQL优化

**索引和SQL层面：**

1. 对经常用于查询的字段添加索引，加强查询效率；
2. 避免使用or、不等于、模糊查询等导致索引失效；
3. 尽量不要全表查询，尽量满足索引覆盖，避免发生回表；
4. 尽量使用连接来替代子查询。

**数据库结构层面：**

1. 尽量在满足需求的前提下使用较小的数据长度；
2. 尽量使用简单的如int之类的数据类型，避免使用text类型；
3. 选择合适的存储引擎；

**硬件层面：**硬盘、内存、网络

附：**Limit优化**：Limit(10000,10)对于MySQL而言，会先查找10010条数据，然后抛弃前10000条数据，最后得出结果。

1. 对于主键有序的情况：对于其优化可以使用子查询定位到查询初始位置，再从该位置向后查找。
2. 对于主键无序的情况，一般采用索引覆盖来进行查询，即先用索引覆盖定位到主键数据，再将数据和表进行join或者子查询。（推荐使用join）

#### 20、ThreadLocal原理和应用场景

**基本概念**：ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。

**ThreadLocal、ThreadLocalMap、Thread关系**：ThreadLocalMap是一个以ThreadLocal为键的Map，底层是自己实现的键值对数组（采用开放地址法解决Hash冲突，所以不需要链表），并没有实现Map接口。每个线程中都有一个ThreadLocalMap对象threadLocals，用来保存threadLocal对应的值。而ThreadLocalMap实际上是ThreadLocal的静态内部类（这主要是ThreadLocalMap没必要绑定到具体的ThreadLocal对象，而且如果放到Thread中会增大开销）

**应用场景：**SimpleDateFormat（https://www.cnblogs.com/zz-ksw/p/12684877.html） 、数据库连接池

#### 21、MySQL MVCC

MySQL通过MVCC(多版本并发控制)实现了不可重复读和可重复读两个事务隔离级别。

**版本链**：

MySQL每条聚簇索引后隐藏着两个列，分别是trx_id和roll_pointer。roll_pointer指向事务更新生成的undo log，从而可以找到每个版本对应的数据；而trx_id表示最近一次更新数据的事务ID。

**read view：**

当事务进行查询时，就会开启一个read view，read view中包括：

1. m_ids ，还未提交的事务id集合
2. low_limit_id，m_ids里最小的值
3. up_limit_id，下一次生成事务ID的最大值
4. creator_trx_id，创建read view的事务ID，也就是自己的事务

**事务读取：**

如果trx_id < low_limit_id，那么说明就是之前的事务数据，直接返回，对应第一次开启事务查询；

如果trx_id > low_limit_id，那么此时就需要根据版本链进行事务查找之前的版本；

如果trx_id = creator_trx_id，说明就是自己修改的，可以直接返回。

**不同事务隔离级别：**

在读已提交的级别下，每次查询都会重新生成一个read view，这也就意味着可能出现一些事务更新数据后提交，出现在另一个事务中的情况；而在可重复读的级别下，一个事务中的读操作使用的是同一个read view，所以不会出现刚才的问题。

**MVCC能否解决幻读问题？**

网上说法不一，不过面试应该说不能，幻读通过间隙锁解决。具体：https://www.zhihu.com/question/422425988

#### 22、什么样的列不适合建立索引

1. 长文本不适合建立
2. 经常性修改的列不适合建立索引
3. where条件中不常用的列
4. 数据重复性太高，如性别
5. 参与列的计算
6. 数据量较小

#### 23、SQL执行顺序

from - on - join- where - group by  - having - select - distinct - order by - limit                                                   

#### 24、三大范式

1. 要求数据库表的每一列都是不可分割的原子数据项。比如学校信息之类的非原子信息必须拆分。
2. 在1NF的基础上，非码属性必须完全依赖于候选码。确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（联合主键），每张表只描述一件事情。比如你不能把商品编号和订单编号两个联系的列全部放在表中。
3. 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

#### 25、Redis过期策略

- **定时删除**
  - 在设置key过期的同时，同时为key创建一个定时器，让定时器在key过期时间来临时，对key进行删除
  - 通过定时删除，可以保证内存被尽快的释放，节约空间
  - 但是也正因为需要对每一个key设置单独的定时器，当key的数量增大时，性能消耗严重
- **惰性删除**
  - key过期的时候不进行删除，等到需要对key进行读取时，发现过期，则再将其删除
  - 只在非删除不可的情况删除，可以减少因为删除操作带来的时间消耗
  - 很多过期key可能因为不被访问而长期停留在内存中，消耗空间
- **定期删除**
  - 每隔一段时间执行一次删除过期key的操作
  - 相比前两者，一定程度上减少了缺点代来的负面作用，但发挥的效用也稍弱于前两者优势
- Redis采用的即是惰性删除+定期删除

#### 26、对象在堆中的内存结构

- Java对象头
  - Mark Word（标记字段）：主要保存的是对象的HashCode、分代年龄、锁标记位信息
  - Klass Point（类型指针）：对象指向它的类元数据的指针，虚拟机通过这个指针判断这个对象是哪个类的实例
- 实例数据：实例数据即时对象真正保存的信息，也就是我们在程序中定义的各种字段的信息。
- 对齐填充：非必须，只是Hot Spot虚拟机要求对象起始地址必须是8的倍数，对象的大小必须是8字节的整数倍，所以最后需要对齐填充来补全。

#### 27、JVM的永久代会发生垃圾回收么

1.该类的实例都被回收

2.加载该类的classLoader已经被回收 

3.该类不能通过反射访问到其方法，而且该类的java.lang.class没有被引用 

当满足这3个条件时，是可以回收，但回不回收还得看jvm。

#### 28、接口和抽象类的区别

- 抽象类用abstract修饰，而接口用interface修饰，前者不支持多继承，后者一个类可以实现多个接口
- 类中有一个抽象方法即为抽象类，本质上是一个类，而接口方法默认且只能是public abstract，变量是public static final修饰
- 两者都没有办法创建实例
- 抽象类本质上是子类的抽象，也就是说概括了子类的通用特性，而接口是在功能层面上，更多的描述的是实现类拥有的一个功能

#### 29、Spring Bean的生命周期

https://www.cnblogs.com/rosa-king/p/10255395.html