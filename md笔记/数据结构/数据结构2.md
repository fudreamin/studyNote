### 9.6 哈夫曼编码

- 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，哈夫曼编码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码（有时也称为霍夫曼编码）。
- 前缀编码 是指对字符集进行编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀。哈夫曼编码满足前缀编码的条件，因为根节点到每个叶子节点的路径都不可能经过其他叶子节点。

- 传输字符串： i like like like java do you like a java
  - d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 // 各个字符对应的个数
  - 按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值

- 构成哈夫曼树步骤：
  1. 从小到大进行排序, 将每一个数据，每个数据都是一个节点， 每个节点可以看成是一颗最简单的二叉树；
  2. 取出根节点权值最小的两颗二叉树；
  3. 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和；
  4. 再将这颗新的二叉树，以根节点的权值大小再次排序， 不断重复1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树。

- 根据赫夫曼树，给各个字符,规定编码(前缀编码)， 向左的路径为0 向右的路径为1。

  o: 1000 u: 10010 d: 100110 y: 100111 i: 101 a : 110 k: 1110 e: 1111 j: 0000 v: 0001 l: 001 : 01

- 按照上面的赫夫曼编码，我们的"i like like like java do you like a java" 字符串对应的编码为(注意这里我们使用的无损压缩)。
  1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110 通过赫夫曼编码处理长度为133。

- 注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的, 最后生成的赫夫曼编码的长度是一样。

- 压缩流程：

```java
import java.util.*;

public class HuffmanCode {

    static Map<Byte, String> map = new HashMap<>();

    public static void main(String[] args) {
        String content = "i like like like java do you like a java";
        byte[] bytes = content.getBytes();//注意，Byte为java.lang包中的一个封装类，而byte是java的基本数据类型
        bytes=huffmanZip(bytes);
        for (int i = 0; i < bytes.length; i++) {
            System.out.println(bytes[i]);
        }
    }


    //封装压缩的所有方法
    private static byte[] huffmanZip(byte[] bytes){
        ArrayList<CNode> list = getNodes(bytes);
        CNode node = createHaffmanTree(list);
        node.preOrder();
        StringBuilder builder = new StringBuilder();
        getCode(node, builder, "");
        bytes = zip(bytes);
        return bytes;
    }

    //将byte数组元素转化为节点list
    private static ArrayList<CNode> getNodes(byte[] bytes) {
        ArrayList<CNode> list = new ArrayList<>();
        HashMap<Byte, Integer> map = new HashMap<>();
        for (byte b : bytes) {
            Integer count = map.get(b);
            map.put(b, count == null ? 1 : count + 1);
        }
        for (Map.Entry<Byte, Integer> entry : map.entrySet()) {
            list.add(new CNode(entry.getKey(), entry.getValue()));
        }
        return list;
    }

    //通过节点list创建哈夫曼树
    private static CNode createHaffmanTree(ArrayList<CNode> list) {
        while (list.size() > 1) {
            Collections.sort(list);
            CNode left = list.get(0);
            CNode right = list.get(1);
            CNode parent = new CNode(left.weight + right.weight);
            parent.left = left;
            parent.right = right;
            list.remove(0);
            list.remove(0);
            list.add(parent);
        }
        return list.get(0);
    }

    //获取每个叶子节点的哈夫曼编码
    private static void getCode(CNode node, StringBuilder builder, String code) {
        StringBuilder builder2 = new StringBuilder(builder);//必须创建builder2，直接是用builder是错误的
        builder2.append(code);
        if (node != null) {
            if (node.data == null) {//叶子节点
                getCode(node.left, builder2, "0");
                getCode(node.right, builder2, "1");
            } else {
                map.put(node.data, builder2.toString());
            }
        }
    }

    //将哈夫曼编码压缩为byte数组
    private static byte[] zip(byte[] bytes) {
        StringBuilder stringBuilder = new StringBuilder();
        for (Byte b : bytes) {
            stringBuilder.append(map.get(b));
        }
        int length = (stringBuilder.length() + 7) / 8;
        byte[] bytes1=new byte[length];
        int index=0;
        for (int i = 0; i < stringBuilder.length(); i+=8) {
            String str;
            if(i+8<stringBuilder.length()){
                str=stringBuilder.substring(i,i+8);
            }else{
                str=stringBuilder.substring(i);
            }
            bytes1[index++]= (byte) Integer.parseInt(str,2);
        }
        return bytes1;
    }

}

class CNode implements Comparable<CNode> {
    Byte data;//存放数据。如：'a'=》97
    int weight;//权重，即字符出现次数
    CNode left;
    CNode right;

    public CNode(Byte data) {
        this.data = data;
    }

    public CNode(int weight) {
        this.weight = weight;
    }

    public CNode(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    //先序遍历
    public void preOrder() {
        System.out.println(this.toString());
        if (left != null) {
            left.preOrder();
        }
        if (right != null) {
            right.preOrder();
        }
    }

    @Override
    public int compareTo(CNode o) {
        return this.weight - o.weight;
    }

    @Override
    public String toString() {
        return "CNode{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }
}
```

### 9.7 二叉排序树（BST)

- 二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。
-  二叉排序树可能是一棵空树；也可能是具有下列性质的二叉树：
  1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
  2. 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；
  3. 左、右子树也分别为二叉排序树；
- 二叉排序树通过中序遍历得到的序列是一个升序序列。

创建和遍历二叉排序树：

```java
//二叉排序树
public class BinarySortTreeTest {
    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9};
        BinarySortTree binarySortTree = new BinarySortTree();
        for (int i = 0; i < arr.length; i++) {
            BNode bNode = new BNode(arr[i]);
            binarySortTree.add(bNode);
        }
        binarySortTree.midOrder();
    }
}

class BinarySortTree {
    BNode root;

    public BinarySortTree() {
    }

    public BinarySortTree(BNode root) {
        this.root = root;
    }

    public void add(BNode node) {
        if (root == null) {
            root = node;
            return;
        }
        root.add(node);
    }

    public void midOrder() {
        if (root == null) {
            System.out.println("树为空");
            return;
        }
        root.midOrder();
    }
}

class BNode {
    int value;
    BNode left;
    BNode right;

    public BNode(int value) {
        this.value = value;
    }

    //添加
    public void add(BNode node) {
        if (node == null) {
            return;
        }
        if (node.value < value) {
            if (left == null) {
                left = node;
            } else {
                left.add(node);
            }
        } else {
            if (right == null) {
                right = node;
            } else {
                right.add(node);
            }
        }
    }

    //中序遍历
    public void midOrder() {
        if (left != null) {
            left.midOrder();
        }
        System.out.print(value + " ");
        if (right != null) {
            right.midOrder();
        }
    }
}

```

- 二叉排序树结点的删除：
  1. 当待删除结点为叶子结点时，删除后不影响整棵树的结构，所以可以直接删除；
  2. 当待删除结点只有一个子结树时，用子结点替代该结点即可；
  3. 当待删除结点左右子树都不为空时，找到需要删除的结点p的直接前驱或直接后继（中序遍历）s，用s来替换结点p，然后再删除此结点s。

```java
package com.dreamin.tree;

//二叉排序树
public class BinarySortTreeTest {
    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9, 0};
        BinarySortTree binarySortTree = new BinarySortTree();
        for (int i = 0; i < arr.length; i++) {
            BNode bNode = new BNode(arr[i]);
            binarySortTree.add(bNode);
        }
        binarySortTree.midOrder();
        System.out.println("删除后：");
        binarySortTree.deleteByValue(3);
        binarySortTree.midOrder();
    }
}

class BinarySortTree {
    BNode root;

    public BinarySortTree() {
    }

    public BinarySortTree(BNode root) {
        this.root = root;
    }

    //查找结点
    public BNode search(int value) {
        if (root == null) {
            return null;
        }
        return root.search(value);
    }

    //查找父节点
    public BNode searchParent(int value) {
        if (root == null) {
            return null;
        }
        return root.searchParent(value);
    }

    //查找后继结点值（即当前节点的右子树所有结点的最小值）
    public int nextNode(BNode node) {
        BNode temp = node.right;
        while (temp.left != null) {
            temp = temp.left;
        }
        deleteByValue(temp.value);//此时temp只有可能是叶子节点或只有一颗子树的结点，所以可以删除
        return temp.value;
    }

    //删除
    public void deleteByValue(int value) {
        if (root == null) {
            return;
        }
        BNode currentNode = search(value);//当前节点
        if (currentNode == null) {
            return;
        }
        BNode pre = searchParent(value);
        //如果是叶子结点，父节点的指向置为空
        if (currentNode.left == null && currentNode.right == null) {
            if (root == currentNode) {
                root = null;
                return;
            }
            if (pre.left != null && pre.left == currentNode) {
                pre.left = null;
            } else if (pre.right != null && pre.right == currentNode) {
                pre.right = null;
            }
        }

        //如果节点有两颗子树
        else if (currentNode.left != null && currentNode.right != null) {
            int next_value = nextNode(currentNode);
            currentNode.value = next_value;
        }
        //如果节点只有一颗子树
        else {
            if (pre == null) {
                if (pre.left != null) {
                    root = pre.left;
                } else {
                    root = pre.right;
                }
            }
            if (pre.left == currentNode && currentNode.left == null) {
                pre.left = currentNode.right;
            } else if (pre.left == currentNode && currentNode.right == null) {
                pre.left = currentNode.left;
            } else if (pre.right == currentNode && currentNode.left == null) {
                pre.right = currentNode.right;
            } else {
                pre.right = currentNode.left;
            }
        }
    }

    //添加
    public void add(BNode node) {
        if (root == null) {
            root = node;
            return;
        }
        root.add(node);
    }

    //中序遍历
    public void midOrder() {
        if (root == null) {
            System.out.println("树为空");
            return;
        }
        root.midOrder();
    }
}

class BNode {
    int value;
    BNode left;
    BNode right;

    public BNode(int value) {
        this.value = value;
    }

    //查找后继结点(即结点右子树中的最小值）
    public int nextNode(BNode node) {
        node = node.right;
        while (node.left != null) {
            node = node.left;
        }
        BNode parentNode = searchParent(node.value);
        if (parentNode.left == node) {
            parentNode.left = null;
        } else {
            parentNode.right = null;
        }
        return node.value;
    }

    //查找父节点
    public BNode searchParent(int value) {
        if ((this.left != null && this.left.value == value) ||
                (this.right != null && this.right.value == value)) {
            return this;
        } else if (this.value > value && this.left != null) {
            return left.searchParent(value);//向左查找
        } else if (this.value < value && this.right != null) {
            return right.searchParent(value);//向右查找
        } else {
            return null;//未找到
        }
    }

    //查找
    public BNode search(int value) {
        if (this.value == value) {
            return this;
        } else if (this.value > value) {//向左查找
            if (this.left == null) {
                return null;//未找到则返回null
            }
            return left.search(value);
        } else {//向右查找
            if (this.right == null) {
                return null;
            }
            return right.search(value);
        }
    }

    //添加
    public void add(BNode node) {
        if (node == null) {
            return;
        }
        if (node.value < value) {
            if (left == null) {
                left = node;
            } else {
                left.add(node);
            }
        } else {
            if (right == null) {
                right = node;
            } else {
                right.add(node);
            }
        }
    }

    //中序遍历
    public void midOrder() {
        if (left != null) {
            left.midOrder();
        }
        System.out.print(value + " ");
        if (right != null) {
            right.midOrder();
        }
    }
}
```

### 9.8 平衡二叉树（AVL树）

- 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL 树， 可以保证查询效率较高。
- 具有以下特点：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。
- 平衡因子 : 树中某结点其左子树的高度和右子树的高度之差。
- **左旋示意图：**

![](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\AVL左旋转.png)

- **右旋转：**（与左子树旋转方法相似）
  1. 创建一个新的结点，值等于当前结点的值；
  2. 把新结点的右子树设置为当前结点的右子树；
  3. 把新结点的左子树设置为当前节点左子树的右子树；
  4. 把当前结点的值替换为左子结点的值；
  5. 让当前结点左子树指向左子结点的左子结点；
  6. 让新结点设置为当前结点的右结点。
- **条件判断：**
  - 当左子树高度-右子树高度 > 1，满足右旋转条件:
    1. 如果它的左子树的右子树高度大于它的左子树的高度，先对当前这个结点的左节点进行左旋转，在对当前结点进行右旋转的操作即可。
    2. 否则直接右转。
  - 当右子树高度-左子树高度 > 1，满足左旋转条件:
    1. 如果它的右子树的左子树高度大于它的右子树的高度，先对当前这个结点的右节点进行右旋转，在对当前结点进行左旋转的操作即可。
    2. 否则直接左转。

```java
package com.dreamin.tree;

//平衡二叉排序树
public class AVLTreeTest {
    public static void main(String[] args) {
//        int[] arr = {4, 3, 6, 5, 7, 8};
//        int[] arr = {10, 12, 8, 9, 7, 6};
        int[] arr = {10,7,11,6,8,9};
        AVLTree avlTree = new AVLTree();
        for (int i = 0; i < arr.length; i++) {
            ANode node = new ANode(arr[i]);
            avlTree.add(node);
        }
        System.out.println("二叉搜索树：");
        avlTree.midOrder();
        System.out.println("\n根节点高度为：" + avlTree.root.height());
    }
}

class AVLTree {
    ANode root;

    public AVLTree() {
    }

    public AVLTree(ANode root) {
        this.root = root;
    }

    //查找结点
    public ANode search(int value) {
        if (root == null) {
            return null;
        }
        return root.search(value);
    }

    //查找父结点
    public ANode searchParent(int value) {
        if (root == null) {
            return null;
        }
        return root.searchParent(value);
    }

    //查找后继结点值（即当前结点的右子树所有结点的最小值）
    public int nextNode(ANode node) {
        ANode temp = node.right;
        while (temp.left != null) {
            temp = temp.left;
        }
        deleteByValue(temp.value);//此时temp只有可能是叶子结点或只有一颗子树的结点，所以可以删除
        return temp.value;
    }

    //删除
    public void deleteByValue(int value) {
        if (root == null) {
            return;
        }
        ANode currentNode = search(value);//当前结点
        if (currentNode == null) {
            return;
        }
        ANode pre = searchParent(value);
        //如果是叶子结点，父结点的指向置为空
        if (currentNode.left == null && currentNode.right == null) {
            if (root == currentNode) {
                root = null;
                return;
            }
            if (pre.left != null && pre.left == currentNode) {
                pre.left = null;
            } else if (pre.right != null && pre.right == currentNode) {
                pre.right = null;
            }
        }

        //如果结点有两颗子树
        else if (currentNode.left != null && currentNode.right != null) {
            int next_value = nextNode(currentNode);
            currentNode.value = next_value;
        }
        //如果结点只有一颗子树
        else {
            if (pre == null) {
                if (pre.left != null) {
                    root = pre.left;
                } else {
                    root = pre.right;
                }
            }
            if (pre.left == currentNode && currentNode.left == null) {
                pre.left = currentNode.right;
            } else if (pre.left == currentNode && currentNode.right == null) {
                pre.left = currentNode.left;
            } else if (pre.right == currentNode && currentNode.left == null) {
                pre.right = currentNode.right;
            } else {
                pre.right = currentNode.left;
            }
        }
    }

    //添加
    public void add(ANode node) {
        if (root == null) {
            root = node;
            return;
        }
        root.add(node);
    }

    //中序遍历
    public void midOrder() {
        if (root == null) {
            System.out.println("树为空");
            return;
        }
        root.midOrder();
    }
}

class ANode {
    int value;
    com.dreamin.tree.ANode left;
    com.dreamin.tree.ANode right;

    public ANode(int value) {
        this.value = value;
    }

    //左旋转,主要是理清步骤
    public void leftRotate() {
        ANode node = new ANode(value);
        node.left = left;
        node.right = right.left;
        value = right.value;
        right = right.right;
        left = node;
    }

    //右旋转
    public void rightRotate() {
        ANode node = new ANode(value);
        node.right = right;
        node.left = left.right;
        value = left.value;
        left = left.left;
        right = node;
    }

    //左子树高度
    public int leftHeight() {
        if (this.left == null) {
            return 0;
        }
        return left.height();
    }

    //右子树高度
    public int rightHeight() {
        if (this.right == null) {
            return 0;
        }
        return right.height();
    }


    //当前结点高度
    public int height() {
        return Math.max(this.left == null ? 0 : left.height(), this.right == null ? 0 : right.height()) + 1;
    }

    //查找后继结点(即结点右子树中的最小值）
    public int nextNode(com.dreamin.tree.ANode node) {
        node = node.right;
        while (node.left != null) {
            node = node.left;
        }
        com.dreamin.tree.ANode parentNode = searchParent(node.value);
        if (parentNode.left == node) {
            parentNode.left = null;
        } else {
            parentNode.right = null;
        }
        return node.value;
    }

    //查找父结点
    public com.dreamin.tree.ANode searchParent(int value) {
        if ((this.left != null && this.left.value == value) ||
                (this.right != null && this.right.value == value)) {
            return this;
        } else if (this.value > value && this.left != null) {
            return left.searchParent(value);//向左查找
        } else if (this.value < value && this.right != null) {
            return right.searchParent(value);//向右查找
        } else {
            return null;//未找到
        }
    }

    //查找
    public com.dreamin.tree.ANode search(int value) {
        if (this.value == value) {
            return this;
        } else if (this.value > value) {//向左查找
            if (this.left == null) {
                return null;//未找到则返回null
            }
            return left.search(value);
        } else {//向右查找
            if (this.right == null) {
                return null;
            }
            return right.search(value);
        }
    }

    //添加
    public void add(com.dreamin.tree.ANode node) {
        if (node == null) {
            return;
        }
        if (node.value < value) {
            if (left == null) {
                left = node;
            } else {
                left.add(node);
            }
        } else {
            if (right == null) {
                right = node;
            } else {
                right.add(node);
            }
        }

        //添加节点时：（右子树高度-左子树高度）> 1，向左旋转
        if (rightHeight() - leftHeight() > 1) {
            if (right != null && right.leftHeight() > right.rightHeight()) {
                right.rightRotate();
            }
            leftRotate();
        }
        //添加节点时：（左子树高度-右子树高度）> 1，向右旋转
        else if (leftHeight() - rightHeight() > 1) {
            if (left != null && left.rightHeight() > left.leftHeight()) {
                left.leftRotate();
            }
            rightRotate();
        }
    }

    //中序遍历
    public void midOrder() {
        if (left != null) {
            left.midOrder();
        }
        System.out.print(value + " ");
        if (right != null) {
            right.midOrder();
        }
    }
}

```

### 9.9 多路查找树

#### 1、2-3树

- 2-3 树是最简单的B 树结构,

- 特点：
  1. 2-3 树的所有叶子节点都在同一层。(只要是B 树都满足这个条件)
  2. 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。
  3. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点。
  4. 2-3 树是由二节点和三节点构成的树。
- 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3 个条件。
- 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则。

#### 2、B树、B+树、B*树

**B树**

- B-tree 树即B 树，B 即Balanced，平衡的意思。有人把B-tree 翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B 树又是另一种树。实际上，B-tree 就是指的B 树。
- 说明：
  1. B 树的阶：节点的最多子节点个数。比如2-3 树的阶是3，2-3-4 树的阶是4。
  2. B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点。
  3. 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据。
  4. 搜索有可能在非叶子结点结束。
  5. 其搜索性能等价于在关键字全集内做一次二分查找。
- 图解：

![](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\B树.jpg)

**B+树**

- B+树是B 树的变体，也是一种多路搜索树。
- 说明：
  1. B+树的搜索与B 树也基本相同，区别是B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。
  2. 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。
  3. 不可能在非叶子结点命中。
  4. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层。
  5. 更适合文件索引系统。
  6. B 树和B+树各有自己的应用场景，不能说B+树完全比B 树好，反之亦然。
- 图解：

![](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\B+树.jpg)

**B*树**

- B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。
- 说明：
  1. B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为的1/2。
  2. 从第1 个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高。
- 图解：

![](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\B新树.jpg)

## 10、图

### 10.1 基本介绍

- 图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为顶点。
- 分类：无向图、有向图、带权图（网）。
- 图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。

**邻接矩阵**

- 邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n 个顶点的图而言，矩阵是的row 和col 表示的是1....n个点。

![](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\邻接矩阵.jpg)

**邻接表**

- 邻接矩阵需要为每个顶点都分配n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失。
- 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成。

![](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\邻接表.jpg)

### 10.2 图的深度优先搜索（DFS)

**说明**

- 深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。
- 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。
- 深度优先搜索是一个递归的过程。

**步骤**

1. 访问初始结点v，并标记结点v 为已访问。
2. 查找结点v 的第一个邻接结点w。
3. 若w 存在，则继续执行4，如果w 不存在，则回到第1 步，将从v 的下一个结点继续。
4. 若w 未被访问，对w 进行深度优先遍历递归（即把w 当做另一个v，然后进行步骤123）。
5. 查找结点v 的w 邻接结点的下一个邻接结点，转到步骤3。

### 10.3 图的广度优先搜索（BFS）

- 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点。

**步骤**

1. 访问初始结点v 并标记结点v 为已访问。
2. 结点v 入队列。
3. 当队列非空时，继续执行，否则算法结束。
4. 出队列，取得队头结点u。
5. 查找结点u 的第一个邻接结点w。
6. 若结点u 的邻接结点w 不存在，则转到步骤3；否则循环执行以下三个步骤：
   1. 若结点w 尚未被访问，则访问结点w 并标记为已访问。
   2. 结点w 入队列。
   3. 查找结点u 的继w 邻接结点后的下一个邻接结点w，转到步骤6。

### 10.4 代码实现

```java
package com.dreamin.graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

//图
public class Graph {

    private ArrayList<String> vertexList;//节点集合
    private int[][] edges;//存储图的邻接矩阵
    private int edgeNum;//边的数量
    private int[] record;
    private LinkedList<Integer> linkedList = new LinkedList<>();

    public static void main(String[] args) {
        Graph graph = new Graph(4);
        String[] vertexs = {"a", "b", "c", "d"};
        for (int i = 0; i < vertexs.length; i++) {
            graph.insertVertex(vertexs[i]);
        }
        graph.saveEdge(0, 2, 1);
        graph.saveEdge(2, 3, 1);
        graph.saveEdge(1, 2, 1);
        graph.showGraph();
        int v = 0;
        System.out.println("深搜结果：");
        System.out.print(v + " ");
        graph.dfs(v);
        System.out.println();
        for (int i = 0; i < graph.record.length; i++) {
            graph.record[i] = 0;
        }
        System.out.println("广搜结果：");
        graph.linkedList.add(v);
        graph.record[0] = 1;
        graph.bfs();
    }

    //深度优先搜索
    public void dfs(int v) {
        record[v] = 1;
        for (int i = 0; i < getVertexNum(); i++) {
            if (edges[v][i] > 0 && record[i] == 0) {
                System.out.print(i + " ");
                dfs(i);
            }
        }
    }

    //广度优先搜索
    public void bfs() {
        int v;
        if (!linkedList.isEmpty())
            v = linkedList.remove();
        else
            return;
        System.out.print(v + " ");
        for (int i = 0; i < getVertexNum(); i++) {
            if (edges[v][i] > 0 && record[i] == 0) {
                linkedList.add(i);
                record[i] = 1;
            }
        }
        bfs();
    }


    //图的初始化
    public Graph(int n) {
        edges = new int[n][n];
        vertexList = new ArrayList<String>(n);
        edgeNum = 0;
        record = new int[n];
    }

    //图的显示
    public void showGraph() {
        for (int[] row : edges) {
            System.out.println(Arrays.toString(row));
        }
    }

    //存储节点
    public void insertVertex(String target) {
        vertexList.add(target);
    }

    //存储边
    public void saveEdge(int i, int j, int weight) {
        edges[i][j] = weight;
        edges[j][i] = weight;
        edgeNum++;
    }

    //返回结点数
    public int getVertexNum() {
        return vertexList.size();
    }

    //返回边数
    public int getEdgeNum() {
        return edgeNum;
    }

    //返回两点权值
    public int getValue(int i, int j) {
        return edges[i][j];
    }

}

```

